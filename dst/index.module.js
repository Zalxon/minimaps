import t,{createContext as e,useContext as n,useRef as r,useState as o,useEffect as a}from"react";import i from"regl";import{extname as l}from"path";import c from"zarr-js";import{geoPath as u,geoGraticule as s}from"d3-geo";import{feature as d}from"topojson-client";function f(){return f=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},f.apply(this,arguments)}var p=e(null),h=function(e){var n=e.style,l=e.aspect,c=e.children,u=r(),s=r(null),d=r(),h=o(!1),v=h[0],m=h[1],g=o({width:null,height:null}),x=g[0],y=g[1];return a(function(){return d.current=function(){s.current.style.height=s.current.offsetWidth*l+"px",y({height:s.current.offsetWidth?s.current.offsetWidth*l:s.current.style.height,width:s.current.offsetWidth})},window.addEventListener("resize",d.current),d.current(),u.current||(u.current=i({container:s.current,extensions:["OES_texture_float","OES_element_index_uint"]}),m(!0)),function(){window.removeEventListener("resize",d.current)}},[l]),a(function(){return function(){u.current&&u.current.destroy(),m(!1)}},[]),/*#__PURE__*/t.createElement(p.Provider,{value:{regl:u.current,viewport:x}},/*#__PURE__*/t.createElement("div",{style:f({width:"100%"},n),ref:s}),v&&c)},v={naturalEarth1:{aspect:.5,scale:1,translate:[0,0]},orthographic:{aspect:1,scale:3,translate:[0,0]},mercator:{aspect:1,scale:1,translate:[0,0]},equirectangular:{aspect:.5,scale:1,translate:[0,0]}},m=e(null),g=function(){return n(m)},x=function(e){var n=e.id,r=e.tabIndex,i=e.className,l=e.children,c=e.projection,u=e.style,s=e.aspect,d=e.scale,p=e.translate,g=o({value:c(),scale:d,aspect:s,translate:p}),x=g[0],y=g[1],w=800;return a(function(){var t=c(),e=v[t.id],n=d||e.scale,r=s||e.aspect,o=p||e.translate;t.scale(n*(w/(2*Math.PI))),t.translate([(1+o[0])*w/2,(1+o[1])*r*w/2]),y({scale:n,aspect:r,value:t,translate:o})},[c,d,s,p]),/*#__PURE__*/t.createElement(m.Provider,{value:{projection:x.value,translate:x.translate,scale:x.scale,aspect:x.aspect,width:w,height:w*x.aspect}},/*#__PURE__*/t.createElement("div",{id:n,tabIndex:r,className:i,style:f({position:"relative",width:"100%",overflow:"hidden"},u)},/*#__PURE__*/t.createElement(h,{aspect:x.aspect,style:{pointerEvents:"none",zIndex:-1}},/*#__PURE__*/t.createElement("svg",{viewBox:"0 0 800 "+w*x.aspect,style:{position:"absolute",width:"100%",top:0,left:0,overflow:"hidden",pointerEvents:"none"}},l))))},y=function(t,e){if(!Object.keys(t).includes(e))throw new Error("variable "+e+" not found in zarr dataset, options are: "+Object.keys(t));return!0},w=function(t){var e=t.data,n=t.lat,r=t.lon;return{lat:[e[n].data.reduce(function(t,e){return Math.min(t,e)}),e[n].data.reduce(function(t,e){return Math.max(t,e)})],lon:[e[r].data.reduce(function(t,e){return Math.min(t,e)}),e[r].data.reduce(function(t,e){return Math.max(t,e)})]}},b=[0,90],E=function(t){var e=t.source,o=t.variable,i=t.mode,u=void 0===i?"rgb":i,s=t.colormap,d=void 0===s?null:s,h=t.clim,v=void 0===h?null:h,m=t.transpose,x=t.northPole,E=void 0===x?b:x,k=t.nullValue,P=void 0===k?-999:k,C=t.bounds,_=void 0===C?null:C,j=t.lat,R=void 0===j?"lat":j,F=t.lon,W=void 0===F?"lon":F,X=n(p),z=X.viewport,O=X.regl,H=g(),I=H.scale,M=H.translate,Y=H.projection;if("lut"==u&&!d)throw new Error("must provide 'colormap' when using 'lut' mode");if("lut"==u&&!v)throw new Error("must provide 'clim' when using 'lut' mode");var G=r(),L=r(),V=r(),N=r(),S=r({}),D=r(!1),T=r(null),A=r(),B=r(null);return a(function(){O.frame(function(t){S.current=t,B.current&&(O.clear({color:[0,0,0,0],depth:1}),G.current(B.current)),B.current=null})},[]),a(function(){V.current||(V.current=O.texture({width:1,height:1,data:[0,0,0,0]})),N.current||(N.current=O.texture());var t={pixelRatio:O.prop("pixelRatio"),viewportWidth:O.prop("viewportWidth"),viewportHeight:O.prop("viewportHeight"),texture:O.prop("texture"),scale:O.prop("scale"),translate:O.prop("translate"),northPole:O.prop("northPole"),transpose:O.prop("transpose"),nullValue:O.prop("nullValue"),bounds:O.prop("bounds")};"lut"===u&&(t=f({},t,{lut:O.prop("lut"),clim:O.prop("clim")})),L.current=O({vert:"\n      #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      #else\n      precision mediump float;\n      #endif\n      attribute vec2 position;\n      varying vec2 uv;\n      void main() {\n        uv = vec2(position.y, position.x);\n        gl_Position = vec4(2.0 * position.x - 1.0, 2.0 * position.y - 1.0, 0.0, 1.0);\n      }\n      ",frag:"\n      #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      #else\n      precision mediump float;\n      #endif\n      varying vec2 uv;\n      uniform vec2 clim;\n      uniform vec4 bounds;\n      uniform float viewportWidth;\n      uniform float viewportHeight;\n      uniform sampler2D texture;\n      uniform float pixelRatio;\n      uniform float scale;\n      uniform vec2 translate;\n      uniform vec2 northPole;\n      uniform bool transpose;\n      uniform float nullValue;\n      "+("lut"===u?"uniform sampler2D lut;":"")+"\n      "+("lut"===u?"uniform vec3 nullColor;":"")+"\n\n      const float pi = 3.14159265358979323846264;\n      const float halfPi = pi * 0.5;\n      const float twoPi = pi * 2.0;\n\n      bool isnan(float val)\n      {\n        return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;\n      }\n\n      vec2 rotateCoords(vec2 coords, vec2 northPole) {\n        // Calculate rotation based of north pole coordinates of rotated grid\n        float phiOffset = northPole.y == 90.0 ? 0.0 : 180.0;\n        float phi = radians(phiOffset + northPole.x);\n        float theta = radians(-1.0 * (90.0 - northPole.y));\n\n        float lon = radians(coords.x);\n        float lat = radians(coords.y);\n\n        // Convert from spherical to cartesian coordinates\n        vec3 unrotatedCoord = vec3(cos(lon) * cos(lat), sin(lon) * cos(lat), sin(lat));\n\n        // From https://en.wikipedia.org/wiki/Rotation_matrix#General_rotations\n        mat3 intrinsicRotation = mat3(\n          cos(phi) * cos(theta), -1.0 * sin(phi), cos(phi) * sin(theta),\n          sin(phi) * cos(theta), cos(phi)       , sin(phi) * sin(theta),\n          -1.0 * sin(theta)    , 0              , cos(theta)\n        );\n\n        vec3 rotatedCoord = intrinsicRotation * unrotatedCoord;\n\n        // Convert from cartesian to spherical coordinates\n        float rotatedLon = degrees(atan(rotatedCoord.y, rotatedCoord.x));\n        float rotatedLat = degrees(asin(rotatedCoord.z));\n\n        return vec2(rotatedLon, rotatedLat);\n      }\n\n      "+Y.glsl.func+"\n      void main() {\n        \n        float width = viewportWidth / pixelRatio;\n        float height = viewportHeight / pixelRatio;\n        float x = gl_FragCoord.x / pixelRatio;\n        float y = gl_FragCoord.y / pixelRatio;\n\n        vec2 delta = vec2((1.0 + translate.x) * width / 2.0, (1.0 - translate.y) * height / 2.0);        \n\n        x = (x - delta.x) / (scale * (width / (pi * 2.0)));\n        "+(m?"y = (delta.y - y) / (scale * (width / (pi * 2.0)));":"y = (y - delta.y) / (scale * (width / (pi * 2.0)));")+"\n\n        vec2 lookup = "+Y.glsl.name+"(x, y);\n        vec2 rotated = rotateCoords(lookup, northPole);\n\n        // Handle points that wrap\n        float offsetX = 0.0;\n        if (rotated.x < bounds[2]) {\n          offsetX = 360.0;\n        } else if (rotated.x > bounds[3]) {\n          offsetX = -360.0;\n        }\n\n        float scaleY = 180.0 / abs(bounds[0] - bounds[1]);\n        float scaleX = 360.0 / abs(bounds[2] - bounds[3]);\n        float translateY = 90.0 + bounds[0];\n        float translateX = 180.0 + bounds[2];\n\n        float rescaledY = scaleY * (radians(rotated.y - translateY) + halfPi) / pi;\n        float rescaledX = scaleX * (radians(rotated.x + offsetX - translateX) + pi) / twoPi;\n\n        vec2 coord;\n        "+(m?"coord = vec2(rescaledX, rescaledY);":"coord = vec2(rescaledY, rescaledX);")+"\n\n        vec4 value = texture2D(texture, coord);\n\n        bool inboundsY = rotated.y > bounds[0] && rotated.y < bounds[1];\n        bool inboundsX = rotated.x + offsetX > bounds[2] && rotated.x + offsetX < bounds[3];\n\n        "+("lut"===u?"\n          vec4 c;\n          if ((!inboundsY || !inboundsX) || (value.x == nullValue || isnan(value.x))) {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n          } else {\n            float rescaled = (value.x - clim.x)/(clim.y - clim.x);\n            c = texture2D(lut, vec2(rescaled, 1.0));\n            gl_FragColor = vec4(c.x, c.y, c.z, 1.0);\n          }":"")+"\n\n        "+("rgb"===u?"\n          if (value.x == nullValue) {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n          } else {\n            gl_FragColor = vec4(value.x , value.y, value.z, 1.0);\n          }\n        ":"")+"\n      }\n      ",attributes:{position:[0,0,0,1,1,0,1,0,0,1,1,1]},uniforms:t,count:6,primitive:"triangles"})},[Y.glsl.name]),G.current=function(t){if(L.current&&D.current){var e=S.current.pixelRatio;L.current({texture:V.current,lut:N.current,bounds:T.current?[T.current.lat[0],T.current.lat[1],T.current.lon[0],T.current.lon[1]]:[-90,90,-180,180],scale:I,translate:M,northPole:E,clim:v,nullValue:P,viewportWidth:z.width*e,viewportHeight:z.height*e,pixelRatio:e})}},a(function(){if("string"==typeof e){var t=l(e);if([".png",".jpg",".jpeg"].includes(t)){var n=document.createElement("img");n.src=e,n.crossOrigin="anonymous",n.onload=function(){setTimeout(function(){D.current=!0,V.current(n),B.current="on image load"},0)}}".zarr"===t&&(o?c().loadGroup(e,function(t,e,n){y(e,o),!_&&e[R]&&e[W]&&(T.current=w({data:e,lat:R,lon:W})),A.current=e,D.current=!0,V.current(A.current[o]),B.current="on zarr group load"}):c().load(e,function(t,e){D.current=!0,V.current(e),B.current="on zarr array load"}))}else o?(y(e,o),!_&&e[R]&&e[W]&&(T.current=w({data:e,lat:R,lon:W})),A.current=e,D.current=!0,V.current(A.current[o]),B.current="on zarr group read"):(D.current=!0,V.current(e),B.current="on zarr array read")},[e,R,W]),a(function(){A.current&&(V.current(A.current[o]),B.current="on variable change")},[o]),a(function(){_&&(T.current=_),B.current="on bounds change"},[_&&_.lat[0],_&&_.lat[1],_&&_.lon[0],_&&_.lon[1]]),a(function(){d&&(N.current({data:d,format:"rgb",shape:[d.length,1]}),B.current="on colormap change")},[d]),a(function(){B.current="on viewport change"},[z]),a(function(){B.current="on prop change"},[v&&v[0],v&&v[1],u,I,M[0],M[1],E?E[0]:void 0,E?E[1]:void 0,P,Y]),null},k=function(e){var n=e.fill,r=e.stroke,i=e.strokeWidth,l=void 0===i?.5:i,c=e.opacity,s=void 0===c?.2:c,d=g(),f=d.projection,p=d.width,h=d.height,v=o(),m=v[0],x=v[1],y=String(Math.floor(100*Math.random()));return a(function(){x(u(f)({type:"Sphere"}))},[f]),/*#__PURE__*/t.createElement("svg",{viewBox:"0 0 "+p+" "+h,style:{position:"absolute",width:"100%",top:0,left:0}},/*#__PURE__*/t.createElement("mask",{id:y},/*#__PURE__*/t.createElement("rect",{x:"0",y:"0",width:"100%",height:"100%",fill:"#FFFFFF"}),/*#__PURE__*/t.createElement("path",{fill:"#000000",id:"circle-cutout",d:m})),/*#__PURE__*/t.createElement("rect",{x:"0",y:"0",width:"100%",height:"100%",mask:"url(#"+y+")",style:{fill:n}}),r&&/*#__PURE__*/t.createElement("path",{fill:"none",stroke:r,strokeWidth:l,opacity:s,style:{vectorEffect:"non-scaling-stroke"},d:m}))},P=function(e){var n=e.source,r=e.feature,i=e.fill,l=void 0===i?"none":i,c=e.stroke,s=void 0===c?"none":c,f=e.strokeWidth,p=void 0===f?.5:f,h=e.opacity,v=void 0===h?.7:h,m=o(),x=m[0],y=m[1],w=o(),b=w[0],E=w[1],k=g().projection;return a(function(){fetch(n).then(function(t){return t.json()}).then(function(t){E(d(t,t.objects[r]))})},[n]),a(function(){y(u(k)(b))},[b,k]),/*#__PURE__*/t.createElement("path",{d:x,stroke:s,fill:l,opacity:v,strokeWidth:p,style:{vectorEffect:"non-scaling-stroke"}})},C=function(e){var n=e.stroke,r=e.strokeWidth,o=void 0===r?.5:r,a=e.step,i=void 0===a?[45,45]:a,l=e.opacity,c=void 0===l?.2:l,d=g().projection,f="mercator"===d.id?0:.1;/*#__PURE__*/return t.createElement("path",{d:u(d)(s().step(i).extentMajor([[-180-f,-90-f],[180+f,90+f]])()),stroke:n,fill:"none",opacity:c,strokeWidth:o,style:{vectorEffect:"non-scaling-stroke"}})};export{C as Graticule,x as Minimap,P as Path,E as Raster,k as Sphere,g as useMinimap};
//# sourceMappingURL=index.module.js.map
