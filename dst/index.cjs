var e=require("react"),t=require("regl"),n=require("path"),r=require("zarr-js"),o=require("d3-geo"),a=require("topojson-client");function i(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var l=/*#__PURE__*/i(e),u=/*#__PURE__*/i(t),c=/*#__PURE__*/i(r);function s(){return s=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},s.apply(this,arguments)}var d=e.createContext(null),f=function(t){var n=t.style,r=t.aspect,o=t.children,a=e.useRef(),i=e.useRef(null),c=e.useRef(),f=e.useState(!1),p=f[0],h=f[1],v=e.useState({width:null,height:null}),m=v[0],g=v[1];return e.useEffect(function(){return c.current=function(){i.current.style.height=i.current.offsetWidth*r+"px",g({height:i.current.offsetWidth?i.current.offsetWidth*r:i.current.style.height,width:i.current.offsetWidth})},window.addEventListener("resize",c.current),c.current(),a.current||(a.current=u.default({container:i.current,extensions:["OES_texture_float","OES_element_index_uint"]}),h(!0)),function(){window.removeEventListener("resize",c.current)}},[r]),e.useEffect(function(){return function(){a.current&&a.current.destroy(),h(!1)}},[]),/*#__PURE__*/l.default.createElement(d.Provider,{value:{regl:a.current,viewport:m}},/*#__PURE__*/l.default.createElement("div",{style:s({width:"100%"},n),ref:i}),p&&o)},p={naturalEarth1:{aspect:.5,scale:1,translate:[0,0]},orthographic:{aspect:1,scale:3,translate:[0,0]},mercator:{aspect:1,scale:1,translate:[0,0]},equirectangular:{aspect:.5,scale:1,translate:[0,0]}},h=e.createContext(null),v=function(){return e.useContext(h)},m=function(e,t){if(!Object.keys(e).includes(t))throw new Error("variable "+t+" not found in zarr dataset, options are: "+Object.keys(e));return!0},g=function(e){var t=e.data,n=e.lat,r=e.lon;return{lat:[t[n].data.reduce(function(e,t){return Math.min(e,t)}),t[n].data.reduce(function(e,t){return Math.max(e,t)})],lon:[t[r].data.reduce(function(e,t){return Math.min(e,t)}),t[r].data.reduce(function(e,t){return Math.max(e,t)})]}},x=[0,90];exports.Graticule=function(e){var t=e.stroke,n=e.strokeWidth,r=void 0===n?.5:n,a=e.step,i=void 0===a?[45,45]:a,u=e.opacity,c=void 0===u?.2:u,s=v().projection,d="mercator"===s.id?0:.1;/*#__PURE__*/return l.default.createElement("path",{d:o.geoPath(s)(o.geoGraticule().step(i).extentMajor([[-180-d,-90-d],[180+d,90+d]])()),stroke:t,fill:"none",opacity:c,strokeWidth:r,style:{vectorEffect:"non-scaling-stroke"}})},exports.Minimap=function(t){var n=t.id,r=t.tabIndex,o=t.className,a=t.children,i=t.projection,u=t.style,c=t.aspect,d=t.scale,v=t.translate,m=e.useState({value:i(),scale:d,aspect:c,translate:v}),g=m[0],x=m[1],y=800;return e.useEffect(function(){var e=i(),t=p[e.id],n=d||t.scale,r=c||t.aspect,o=v||t.translate;e.scale(n*(y/(2*Math.PI))),e.translate([(1+o[0])*y/2,(1+o[1])*r*y/2]),x({scale:n,aspect:r,value:e,translate:o})},[i,d,c,v]),/*#__PURE__*/l.default.createElement(h.Provider,{value:{projection:g.value,translate:g.translate,scale:g.scale,aspect:g.aspect,width:y,height:y*g.aspect}},/*#__PURE__*/l.default.createElement("div",{id:n,tabIndex:r,className:o,style:s({position:"relative",width:"100%",overflow:"hidden"},u)},/*#__PURE__*/l.default.createElement(f,{aspect:g.aspect,style:{pointerEvents:"none",zIndex:-1}},/*#__PURE__*/l.default.createElement("svg",{viewBox:"0 0 800 "+y*g.aspect,style:{position:"absolute",width:"100%",top:0,left:0,overflow:"hidden",pointerEvents:"none"}},a))))},exports.Path=function(t){var n=t.source,r=t.feature,i=t.fill,u=void 0===i?"none":i,c=t.stroke,s=void 0===c?"none":c,d=t.strokeWidth,f=void 0===d?.5:d,p=t.opacity,h=void 0===p?.7:p,m=e.useState(),g=m[0],x=m[1],y=e.useState(),w=y[0],b=y[1],E=v().projection;return e.useEffect(function(){fetch(n).then(function(e){return e.json()}).then(function(e){b(a.feature(e,e.objects[r]))})},[n]),e.useEffect(function(){x(o.geoPath(E)(w))},[w,E]),/*#__PURE__*/l.default.createElement("path",{d:g,stroke:s,fill:u,opacity:h,strokeWidth:f,style:{vectorEffect:"non-scaling-stroke"}})},exports.Raster=function(t){var r=t.source,o=t.variable,a=t.mode,i=void 0===a?"rgb":a,l=t.colormap,u=void 0===l?null:l,f=t.clim,p=void 0===f?null:f,h=t.transpose,y=t.northPole,w=void 0===y?x:y,b=t.nullValue,E=void 0===b?-999:b,R=t.bounds,P=void 0===R?null:R,C=t.lat,k=void 0===C?"lat":C,_=t.lon,j=void 0===_?"lon":_,F=e.useContext(d),W=F.viewport,X=F.regl,z=v(),O=z.scale,S=z.translate,M=z.projection;if("lut"==i&&!u)throw new Error("must provide 'colormap' when using 'lut' mode");if("lut"==i&&!p)throw new Error("must provide 'clim' when using 'lut' mode");var G=e.useRef(),H=e.useRef(),I=e.useRef(),Y=e.useRef(),L=e.useRef({}),q=e.useRef(!1),V=e.useRef(null),N=e.useRef(),D=e.useRef(null);return e.useEffect(function(){X.frame(function(e){L.current=e,D.current&&(X.clear({color:[0,0,0,0],depth:1}),G.current(D.current)),D.current=null})},[]),e.useEffect(function(){I.current||(I.current=X.texture({width:1,height:1,data:[0,0,0,0]})),Y.current||(Y.current=X.texture());var e={pixelRatio:X.prop("pixelRatio"),viewportWidth:X.prop("viewportWidth"),viewportHeight:X.prop("viewportHeight"),texture:X.prop("texture"),scale:X.prop("scale"),translate:X.prop("translate"),northPole:X.prop("northPole"),transpose:X.prop("transpose"),nullValue:X.prop("nullValue"),bounds:X.prop("bounds")};"lut"===i&&(e=s({},e,{lut:X.prop("lut"),clim:X.prop("clim")})),H.current=X({vert:"\n      #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      #else\n      precision mediump float;\n      #endif\n      attribute vec2 position;\n      varying vec2 uv;\n      void main() {\n        uv = vec2(position.y, position.x);\n        gl_Position = vec4(2.0 * position.x - 1.0, 2.0 * position.y - 1.0, 0.0, 1.0);\n      }\n      ",frag:"\n      #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      #else\n      precision mediump float;\n      #endif\n      varying vec2 uv;\n      uniform vec2 clim;\n      uniform vec4 bounds;\n      uniform float viewportWidth;\n      uniform float viewportHeight;\n      uniform sampler2D texture;\n      uniform float pixelRatio;\n      uniform float scale;\n      uniform vec2 translate;\n      uniform vec2 northPole;\n      uniform bool transpose;\n      uniform float nullValue;\n      "+("lut"===i?"uniform sampler2D lut;":"")+"\n      "+("lut"===i?"uniform vec3 nullColor;":"")+"\n\n      const float pi = 3.14159265358979323846264;\n      const float halfPi = pi * 0.5;\n      const float twoPi = pi * 2.0;\n\n      bool isnan(float val)\n      {\n        return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;\n      }\n\n      vec2 rotateCoords(vec2 coords, vec2 northPole) {\n        // Calculate rotation based of north pole coordinates of rotated grid\n        float phiOffset = northPole.y == 90.0 ? 0.0 : 180.0;\n        float phi = radians(phiOffset + northPole.x);\n        float theta = radians(-1.0 * (90.0 - northPole.y));\n\n        float lon = radians(coords.x);\n        float lat = radians(coords.y);\n\n        // Convert from spherical to cartesian coordinates\n        vec3 unrotatedCoord = vec3(cos(lon) * cos(lat), sin(lon) * cos(lat), sin(lat));\n\n        // From https://en.wikipedia.org/wiki/Rotation_matrix#General_rotations\n        mat3 intrinsicRotation = mat3(\n          cos(phi) * cos(theta), -1.0 * sin(phi), cos(phi) * sin(theta),\n          sin(phi) * cos(theta), cos(phi)       , sin(phi) * sin(theta),\n          -1.0 * sin(theta)    , 0              , cos(theta)\n        );\n\n        vec3 rotatedCoord = intrinsicRotation * unrotatedCoord;\n\n        // Convert from cartesian to spherical coordinates\n        float rotatedLon = degrees(atan(rotatedCoord.y, rotatedCoord.x));\n        float rotatedLat = degrees(asin(rotatedCoord.z));\n\n        return vec2(rotatedLon, rotatedLat);\n      }\n\n      "+M.glsl.func+"\n      void main() {\n        \n        float width = viewportWidth / pixelRatio;\n        float height = viewportHeight / pixelRatio;\n        float x = gl_FragCoord.x / pixelRatio;\n        float y = gl_FragCoord.y / pixelRatio;\n\n        vec2 delta = vec2((1.0 + translate.x) * width / 2.0, (1.0 - translate.y) * height / 2.0);        \n\n        x = (x - delta.x) / (scale * (width / (pi * 2.0)));\n        "+(h?"y = (delta.y - y) / (scale * (width / (pi * 2.0)));":"y = (y - delta.y) / (scale * (width / (pi * 2.0)));")+"\n\n        vec2 lookup = "+M.glsl.name+"(x, y);\n        vec2 rotated = rotateCoords(lookup, northPole);\n\n        // Handle points that wrap\n        float offsetX = 0.0;\n        if (rotated.x < bounds[2]) {\n          offsetX = 360.0;\n        } else if (rotated.x > bounds[3]) {\n          offsetX = -360.0;\n        }\n\n        float scaleY = 180.0 / abs(bounds[0] - bounds[1]);\n        float scaleX = 360.0 / abs(bounds[2] - bounds[3]);\n        float translateY = 90.0 + bounds[0];\n        float translateX = 180.0 + bounds[2];\n\n        float rescaledY = scaleY * (radians(rotated.y - translateY) + halfPi) / pi;\n        float rescaledX = scaleX * (radians(rotated.x + offsetX - translateX) + pi) / twoPi;\n\n        vec2 coord;\n        "+(h?"coord = vec2(rescaledX, rescaledY);":"coord = vec2(rescaledY, rescaledX);")+"\n\n        vec4 value = texture2D(texture, coord);\n\n        bool inboundsY = rotated.y > bounds[0] && rotated.y < bounds[1];\n        bool inboundsX = rotated.x + offsetX > bounds[2] && rotated.x + offsetX < bounds[3];\n\n        "+("lut"===i?"\n          vec4 c;\n          if ((!inboundsY || !inboundsX) || (value.x == nullValue || isnan(value.x))) {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n          } else {\n            float rescaled = (value.x - clim.x)/(clim.y - clim.x);\n            c = texture2D(lut, vec2(rescaled, 1.0));\n            gl_FragColor = vec4(c.x, c.y, c.z, 1.0);\n          }":"")+"\n\n        "+("rgb"===i?"\n          if (value.x == nullValue) {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n          } else {\n            gl_FragColor = vec4(value.x , value.y, value.z, 1.0);\n          }\n        ":"")+"\n      }\n      ",attributes:{position:[0,0,0,1,1,0,1,0,0,1,1,1]},uniforms:e,count:6,primitive:"triangles"})},[M.glsl.name]),G.current=function(e){if(H.current&&q.current){var t=L.current.pixelRatio;H.current({texture:I.current,lut:Y.current,bounds:V.current?[V.current.lat[0],V.current.lat[1],V.current.lon[0],V.current.lon[1]]:[-90,90,-180,180],scale:O,translate:S,northPole:w,clim:p,nullValue:E,viewportWidth:W.width*t,viewportHeight:W.height*t,pixelRatio:t})}},e.useEffect(function(){if("string"==typeof r){var e=n.extname(r);if([".png",".jpg",".jpeg"].includes(e)){var t=document.createElement("img");t.src=r,t.crossOrigin="anonymous",t.onload=function(){setTimeout(function(){q.current=!0,I.current(t),D.current="on image load"},0)}}".zarr"===e&&(o?c.default().loadGroup(r,function(e,t,n){m(t,o),!P&&t[k]&&t[j]&&(V.current=g({data:t,lat:k,lon:j})),N.current=t,q.current=!0,I.current(N.current[o]),D.current="on zarr group load"}):c.default().load(r,function(e,t){q.current=!0,I.current(t),D.current="on zarr array load"}))}else o?(m(r,o),!P&&r[k]&&r[j]&&(V.current=g({data:r,lat:k,lon:j})),N.current=r,q.current=!0,I.current(N.current[o]),D.current="on zarr group read"):(q.current=!0,I.current(r),D.current="on zarr array read")},[r,k,j]),e.useEffect(function(){N.current&&(I.current(N.current[o]),D.current="on variable change")},[o]),e.useEffect(function(){P&&(V.current=P),D.current="on bounds change"},[P&&P.lat[0],P&&P.lat[1],P&&P.lon[0],P&&P.lon[1]]),e.useEffect(function(){u&&(Y.current({data:u,format:"rgb",shape:[u.length,1]}),D.current="on colormap change")},[u]),e.useEffect(function(){D.current="on viewport change"},[W]),e.useEffect(function(){D.current="on prop change"},[p&&p[0],p&&p[1],i,O,S[0],S[1],w?w[0]:void 0,w?w[1]:void 0,E,M]),null},exports.Sphere=function(t){var n=t.fill,r=t.stroke,a=t.strokeWidth,i=void 0===a?.5:a,u=t.opacity,c=void 0===u?.2:u,s=v(),d=s.projection,f=s.width,p=s.height,h=e.useState(),m=h[0],g=h[1],x=String(Math.floor(100*Math.random()));return e.useEffect(function(){g(o.geoPath(d)({type:"Sphere"}))},[d]),/*#__PURE__*/l.default.createElement("svg",{viewBox:"0 0 "+f+" "+p,style:{position:"absolute",width:"100%",top:0,left:0}},/*#__PURE__*/l.default.createElement("mask",{id:x},/*#__PURE__*/l.default.createElement("rect",{x:"0",y:"0",width:"100%",height:"100%",fill:"#FFFFFF"}),/*#__PURE__*/l.default.createElement("path",{fill:"#000000",id:"circle-cutout",d:m})),/*#__PURE__*/l.default.createElement("rect",{x:"0",y:"0",width:"100%",height:"100%",mask:"url(#"+x+")",style:{fill:n}}),r&&/*#__PURE__*/l.default.createElement("path",{fill:"none",stroke:r,strokeWidth:i,opacity:c,style:{vectorEffect:"non-scaling-stroke"},d:m}))},exports.useMinimap=v;
//# sourceMappingURL=index.cjs.map
