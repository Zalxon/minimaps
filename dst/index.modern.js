import t,{createContext as e,useContext as n,useRef as r,useState as o,useEffect as a}from"react";import l from"regl";import{extname as i}from"path";import c from"zarr-js";import{geoPath as s,geoGraticule as u}from"d3-geo";import{feature as d}from"topojson-client";function p(){return p=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},p.apply(this,arguments)}const h=e(null),f=({style:e,aspect:n,children:i})=>{const c=r(),s=r(null),u=r(),[d,f]=o(!1),[v,m]=o({width:null,height:null});return a(()=>(u.current=()=>{s.current.style.height=s.current.offsetWidth*n+"px",m({height:s.current.offsetWidth?s.current.offsetWidth*n:s.current.style.height,width:s.current.offsetWidth})},window.addEventListener("resize",u.current),u.current(),c.current||(c.current=l({container:s.current,extensions:["OES_texture_float","OES_element_index_uint"]}),f(!0)),()=>{window.removeEventListener("resize",u.current)}),[n]),a(()=>()=>{c.current&&c.current.destroy(),f(!1)},[]),/*#__PURE__*/t.createElement(h.Provider,{value:{regl:c.current,viewport:v}},/*#__PURE__*/t.createElement("div",{style:p({width:"100%"},e),ref:s}),d&&i)},v={naturalEarth1:{aspect:.5,scale:1,translate:[0,0]},orthographic:{aspect:1,scale:3,translate:[0,0]},mercator:{aspect:1,scale:1,translate:[0,0]},equirectangular:{aspect:.5,scale:1,translate:[0,0]}},m=e(null),g=()=>n(m),x=({id:e,tabIndex:n,className:r,children:l,projection:i,style:c,aspect:s,scale:u,translate:d})=>{const[h,g]=o({value:i(),scale:u,aspect:s,translate:d}),x=800;return a(()=>{const t=i(),e=v[t.id],n=u||e.scale,r=s||e.aspect,o=d||e.translate;t.scale(n*(x/(2*Math.PI))),t.translate([(1+o[0])*x/2,(1+o[1])*r*x/2]),g({scale:n,aspect:r,value:t,translate:o})},[i,u,s,d]),/*#__PURE__*/t.createElement(m.Provider,{value:{projection:h.value,translate:h.translate,scale:h.scale,aspect:h.aspect,width:x,height:x*h.aspect}},/*#__PURE__*/t.createElement("div",{id:e,tabIndex:n,className:r,style:p({position:"relative",width:"100%",overflow:"hidden"},c)},/*#__PURE__*/t.createElement(f,{aspect:h.aspect,style:{pointerEvents:"none",zIndex:-1}},/*#__PURE__*/t.createElement("svg",{viewBox:"0 0 800 "+x*h.aspect,style:{position:"absolute",width:"100%",top:0,left:0,overflow:"hidden",pointerEvents:"none"}},l))))},y=(t,e)=>{if(!Object.keys(t).includes(e))throw new Error(`variable ${e} not found in zarr dataset, options are: ${Object.keys(t)}`);return!0},w=({data:t,lat:e,lon:n})=>({lat:[t[e].data.reduce((t,e)=>Math.min(t,e)),t[e].data.reduce((t,e)=>Math.max(t,e))],lon:[t[n].data.reduce((t,e)=>Math.min(t,e)),t[n].data.reduce((t,e)=>Math.max(t,e))]}),b=[0,90],E=({source:t,variable:e,mode:o="rgb",colormap:l=null,clim:s=null,transpose:u,northPole:d=b,nullValue:f=-999,bounds:v=null,lat:m="lat",lon:x="lon"})=>{const{viewport:E,regl:k}=n(h),{scale:P,translate:C,projection:_}=g();if("lut"==o&&!l)throw new Error("must provide 'colormap' when using 'lut' mode");if("lut"==o&&!s)throw new Error("must provide 'clim' when using 'lut' mode");const j=r(),R=r(),F=r(),W=r(),X=r({}),z=r(!1),O=r(null),$=r(),H=r(null);return a(()=>{k.frame(t=>{X.current=t,H.current&&(k.clear({color:[0,0,0,0],depth:1}),j.current(H.current)),H.current=null})},[]),a(()=>{F.current||(F.current=k.texture({width:1,height:1,data:[0,0,0,0]})),W.current||(W.current=k.texture());let t={pixelRatio:k.prop("pixelRatio"),viewportWidth:k.prop("viewportWidth"),viewportHeight:k.prop("viewportHeight"),texture:k.prop("texture"),scale:k.prop("scale"),translate:k.prop("translate"),northPole:k.prop("northPole"),transpose:k.prop("transpose"),nullValue:k.prop("nullValue"),bounds:k.prop("bounds")};"lut"===o&&(t=p({},t,{lut:k.prop("lut"),clim:k.prop("clim")})),R.current=k({vert:"\n      #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      #else\n      precision mediump float;\n      #endif\n      attribute vec2 position;\n      varying vec2 uv;\n      void main() {\n        uv = vec2(position.y, position.x);\n        gl_Position = vec4(2.0 * position.x - 1.0, 2.0 * position.y - 1.0, 0.0, 1.0);\n      }\n      ",frag:`\n      #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      #else\n      precision mediump float;\n      #endif\n      varying vec2 uv;\n      uniform vec2 clim;\n      uniform vec4 bounds;\n      uniform float viewportWidth;\n      uniform float viewportHeight;\n      uniform sampler2D texture;\n      uniform float pixelRatio;\n      uniform float scale;\n      uniform vec2 translate;\n      uniform vec2 northPole;\n      uniform bool transpose;\n      uniform float nullValue;\n      ${"lut"===o?"uniform sampler2D lut;":""}\n      ${"lut"===o?"uniform vec3 nullColor;":""}\n\n      const float pi = 3.14159265358979323846264;\n      const float halfPi = pi * 0.5;\n      const float twoPi = pi * 2.0;\n\n      bool isnan(float val)\n      {\n        return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;\n      }\n\n      vec2 rotateCoords(vec2 coords, vec2 northPole) {\n        // Calculate rotation based of north pole coordinates of rotated grid\n        float phiOffset = northPole.y == 90.0 ? 0.0 : 180.0;\n        float phi = radians(phiOffset + northPole.x);\n        float theta = radians(-1.0 * (90.0 - northPole.y));\n\n        float lon = radians(coords.x);\n        float lat = radians(coords.y);\n\n        // Convert from spherical to cartesian coordinates\n        vec3 unrotatedCoord = vec3(cos(lon) * cos(lat), sin(lon) * cos(lat), sin(lat));\n\n        // From https://en.wikipedia.org/wiki/Rotation_matrix#General_rotations\n        mat3 intrinsicRotation = mat3(\n          cos(phi) * cos(theta), -1.0 * sin(phi), cos(phi) * sin(theta),\n          sin(phi) * cos(theta), cos(phi)       , sin(phi) * sin(theta),\n          -1.0 * sin(theta)    , 0              , cos(theta)\n        );\n\n        vec3 rotatedCoord = intrinsicRotation * unrotatedCoord;\n\n        // Convert from cartesian to spherical coordinates\n        float rotatedLon = degrees(atan(rotatedCoord.y, rotatedCoord.x));\n        float rotatedLat = degrees(asin(rotatedCoord.z));\n\n        return vec2(rotatedLon, rotatedLat);\n      }\n\n      ${_.glsl.func}\n      void main() {\n        \n        float width = viewportWidth / pixelRatio;\n        float height = viewportHeight / pixelRatio;\n        float x = gl_FragCoord.x / pixelRatio;\n        float y = gl_FragCoord.y / pixelRatio;\n\n        vec2 delta = vec2((1.0 + translate.x) * width / 2.0, (1.0 - translate.y) * height / 2.0);        \n\n        x = (x - delta.x) / (scale * (width / (pi * 2.0)));\n        ${u?"y = (delta.y - y) / (scale * (width / (pi * 2.0)));":"y = (y - delta.y) / (scale * (width / (pi * 2.0)));"}\n\n        vec2 lookup = ${_.glsl.name}(x, y);\n        vec2 rotated = rotateCoords(lookup, northPole);\n\n        // Handle points that wrap\n        float offsetX = 0.0;\n        if (rotated.x < bounds[2]) {\n          offsetX = 360.0;\n        } else if (rotated.x > bounds[3]) {\n          offsetX = -360.0;\n        }\n\n        float scaleY = 180.0 / abs(bounds[0] - bounds[1]);\n        float scaleX = 360.0 / abs(bounds[2] - bounds[3]);\n        float translateY = 90.0 + bounds[0];\n        float translateX = 180.0 + bounds[2];\n\n        float rescaledY = scaleY * (radians(rotated.y - translateY) + halfPi) / pi;\n        float rescaledX = scaleX * (radians(rotated.x + offsetX - translateX) + pi) / twoPi;\n\n        vec2 coord;\n        ${u?"coord = vec2(rescaledX, rescaledY);":"coord = vec2(rescaledY, rescaledX);"}\n\n        vec4 value = texture2D(texture, coord);\n\n        bool inboundsY = rotated.y > bounds[0] && rotated.y < bounds[1];\n        bool inboundsX = rotated.x + offsetX > bounds[2] && rotated.x + offsetX < bounds[3];\n\n        ${"lut"===o?"\n          vec4 c;\n          if ((!inboundsY || !inboundsX) || (value.x == nullValue || isnan(value.x))) {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n          } else {\n            float rescaled = (value.x - clim.x)/(clim.y - clim.x);\n            c = texture2D(lut, vec2(rescaled, 1.0));\n            gl_FragColor = vec4(c.x, c.y, c.z, 1.0);\n          }":""}\n\n        ${"rgb"===o?"\n          if (value.x == nullValue) {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n          } else {\n            gl_FragColor = vec4(value.x , value.y, value.z, 1.0);\n          }\n        ":""}\n      }\n      `,attributes:{position:[0,0,0,1,1,0,1,0,0,1,1,1]},uniforms:t,count:6,primitive:"triangles"})},[_.glsl.name]),j.current=t=>{if(R.current&&z.current){const{pixelRatio:t}=X.current;R.current({texture:F.current,lut:W.current,bounds:O.current?[O.current.lat[0],O.current.lat[1],O.current.lon[0],O.current.lon[1]]:[-90,90,-180,180],scale:P,translate:C,northPole:d,clim:s,nullValue:f,viewportWidth:E.width*t,viewportHeight:E.height*t,pixelRatio:t})}},a(()=>{if("string"==typeof t){const n=i(t);if([".png",".jpg",".jpeg"].includes(n)){const e=document.createElement("img");e.src=t,e.crossOrigin="anonymous",e.onload=function(){setTimeout(()=>{z.current=!0,F.current(e),H.current="on image load"},0)}}".zarr"===n&&(e?c().loadGroup(t,(t,n,r)=>{y(n,e),!v&&n[m]&&n[x]&&(O.current=w({data:n,lat:m,lon:x})),$.current=n,z.current=!0,F.current($.current[e]),H.current="on zarr group load"}):c().load(t,(t,e)=>{z.current=!0,F.current(e),H.current="on zarr array load"}))}else e?(y(t,e),!v&&t[m]&&t[x]&&(O.current=w({data:t,lat:m,lon:x})),$.current=t,z.current=!0,F.current($.current[e]),H.current="on zarr group read"):(z.current=!0,F.current(t),H.current="on zarr array read")},[t,m,x]),a(()=>{$.current&&(F.current($.current[e]),H.current="on variable change")},[e]),a(()=>{v&&(O.current=v),H.current="on bounds change"},[v&&v.lat[0],v&&v.lat[1],v&&v.lon[0],v&&v.lon[1]]),a(()=>{l&&(W.current({data:l,format:"rgb",shape:[l.length,1]}),H.current="on colormap change")},[l]),a(()=>{H.current="on viewport change"},[E]),a(()=>{H.current="on prop change"},[s&&s[0],s&&s[1],o,P,C[0],C[1],d?d[0]:void 0,d?d[1]:void 0,f,_]),null},k=({fill:e,stroke:n,strokeWidth:r=.5,opacity:l=.2})=>{const{projection:i,width:c,height:u}=g(),[d,p]=o(),h=String(Math.floor(100*Math.random()));return a(()=>{p(s(i)({type:"Sphere"}))},[i]),/*#__PURE__*/t.createElement("svg",{viewBox:`0 0 ${c} ${u}`,style:{position:"absolute",width:"100%",top:0,left:0}},/*#__PURE__*/t.createElement("mask",{id:h},/*#__PURE__*/t.createElement("rect",{x:"0",y:"0",width:"100%",height:"100%",fill:"#FFFFFF"}),/*#__PURE__*/t.createElement("path",{fill:"#000000",id:"circle-cutout",d})),/*#__PURE__*/t.createElement("rect",{x:"0",y:"0",width:"100%",height:"100%",mask:`url(#${h})`,style:{fill:e}}),n&&/*#__PURE__*/t.createElement("path",{fill:"none",stroke:n,strokeWidth:r,opacity:l,style:{vectorEffect:"non-scaling-stroke"},d}))},P=({source:e,feature:n,fill:r="none",stroke:l="none",strokeWidth:i=.5,opacity:c=.7})=>{const[u,p]=o(),[h,f]=o(),{projection:v}=g();return a(()=>{fetch(e).then(t=>t.json()).then(t=>{f(d(t,t.objects[n]))})},[e]),a(()=>{p(s(v)(h))},[h,v]),/*#__PURE__*/t.createElement("path",{d:u,stroke:l,fill:r,opacity:c,strokeWidth:i,style:{vectorEffect:"non-scaling-stroke"}})},C=({stroke:e,strokeWidth:n=.5,step:r=[45,45],opacity:o=.2})=>{const{projection:a}=g(),l="mercator"===a.id?0:.1;/*#__PURE__*/return t.createElement("path",{d:s(a)(u().step(r).extentMajor([[-180-l,-90-l],[180+l,90+l]])()),stroke:e,fill:"none",opacity:o,strokeWidth:n,style:{vectorEffect:"non-scaling-stroke"}})};export{C as Graticule,x as Minimap,P as Path,E as Raster,k as Sphere,g as useMinimap};
//# sourceMappingURL=index.modern.js.map
