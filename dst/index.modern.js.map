{"version":3,"file":"index.modern.js","sources":["../src/regl.js","../src/minimap.js","../src/raster.js","../src/sphere.js","../src/path.js","../src/graticule.js"],"sourcesContent":["import React, {\n  createContext,\n  useCallback,\n  useState,\n  useEffect,\n  useContext,\n  useRef,\n} from 'react'\nimport _regl from 'regl'\n\nexport const ReglContext = createContext(null)\n\nexport const useRegl = () => {\n  return useContext(ReglContext)\n}\n\nconst Regl = ({ style, aspect, children }) => {\n  const regl = useRef()\n  const container = useRef(null)\n  const resize = useRef()\n  const [ready, setReady] = useState(false)\n  const [viewport, setViewport] = useState({ width: null, height: null })\n\n  useEffect(() => {\n    resize.current = () => {\n      container.current.style.height =\n        container.current.offsetWidth * aspect + 'px'\n\n      setViewport({\n        height: container.current.offsetWidth\n          ? container.current.offsetWidth * aspect\n          : container.current.style.height,\n        width: container.current.offsetWidth,\n      })\n    }\n    window.addEventListener('resize', resize.current)\n    resize.current()\n\n    if (!regl.current) {\n      regl.current = _regl({\n        container: container.current,\n        extensions: ['OES_texture_float', 'OES_element_index_uint'],\n      })\n      setReady(true)\n    }\n\n    return () => {\n      window.removeEventListener('resize', resize.current)\n    }\n  }, [aspect])\n\n  useEffect(() => {\n    return () => {\n      if (regl.current) regl.current.destroy()\n      setReady(false)\n    }\n  }, [])\n\n  return (\n    <ReglContext.Provider\n      value={{\n        regl: regl.current,\n        viewport,\n      }}\n    >\n      <div style={{ width: '100%', ...style }} ref={container} />\n      {ready && children}\n    </ReglContext.Provider>\n  )\n}\n\nexport default Regl\n","import React, {\n  useState,\n  useEffect,\n  useRef,\n  createContext,\n  useContext,\n} from 'react'\nimport Regl from './regl'\n\nconst DEFAULTS = {\n  naturalEarth1: {\n    aspect: 0.5,\n    scale: 1,\n    translate: [0, 0],\n  },\n  orthographic: {\n    aspect: 1,\n    scale: 3,\n    translate: [0, 0],\n  },\n  mercator: {\n    aspect: 1,\n    scale: 1,\n    translate: [0, 0],\n  },\n  equirectangular: {\n    aspect: 0.5,\n    scale: 1,\n    translate: [0, 0],\n  },\n}\n\nconst MinimapContext = createContext(null)\n\nexport const useMinimap = () => {\n  return useContext(MinimapContext)\n}\n\nconst Minimap = ({\n  id,\n  tabIndex,\n  className,\n  children,\n  projection: getProjection,\n  style,\n  aspect: aspectProp,\n  scale: scaleProp,\n  translate: translateProp,\n}) => {\n  const [projection, setProjection] = useState({\n    value: getProjection(),\n    scale: scaleProp,\n    aspect: aspectProp,\n    translate: translateProp,\n  })\n\n  const WIDTH = 800\n\n  useEffect(() => {\n    const updatedProjection = getProjection()\n    const defaults = DEFAULTS[updatedProjection.id]\n    const updatedScale = scaleProp || defaults.scale\n    const updatedAspect = aspectProp || defaults.aspect\n    const updatedTranslate = translateProp || defaults.translate\n\n    updatedProjection.scale(updatedScale * (WIDTH / (2 * Math.PI)))\n    updatedProjection.translate([\n      ((1 + updatedTranslate[0]) * WIDTH) / 2,\n      ((1 + updatedTranslate[1]) * updatedAspect * WIDTH) / 2,\n    ])\n\n    setProjection({\n      scale: updatedScale,\n      aspect: updatedAspect,\n      value: updatedProjection,\n      translate: updatedTranslate,\n    })\n  }, [getProjection, scaleProp, aspectProp, translateProp])\n\n  return (\n    <MinimapContext.Provider\n      value={{\n        projection: projection.value,\n        translate: projection.translate,\n        scale: projection.scale,\n        aspect: projection.aspect,\n        width: WIDTH,\n        height: WIDTH * projection.aspect,\n      }}\n    >\n      <div\n        id={id}\n        tabIndex={tabIndex}\n        className={className}\n        style={{\n          position: 'relative',\n          width: '100%',\n          overflow: 'hidden',\n          ...style,\n        }}\n      >\n        <Regl\n          aspect={projection.aspect}\n          style={{\n            pointerEvents: 'none',\n            zIndex: -1,\n          }}\n        >\n          <svg\n            viewBox={`0 0 ${WIDTH} ${WIDTH * projection.aspect}`}\n            style={{\n              position: 'absolute',\n              width: '100%',\n              top: 0,\n              left: 0,\n              overflow: 'hidden',\n              pointerEvents: 'none',\n            }}\n          >\n            {children}\n          </svg>\n        </Regl>\n      </div>\n    </MinimapContext.Provider>\n  )\n}\n\nexport default Minimap\n","import React, { useState, useEffect, useRef } from 'react'\nimport { extname } from 'path'\nimport { useRegl } from './regl'\nimport { useMinimap } from './minimap'\nimport zarr from 'zarr-js'\n\nconst validateGroup = (data, variable) => {\n  if (!Object.keys(data).includes(variable)) {\n    throw new Error(\n      `variable ${variable} not found in zarr dataset, options are: ${Object.keys(\n        data\n      )}`\n    )\n  }\n\n  return true\n}\n\nconst getBounds = ({ data, lat, lon }) => {\n  return {\n    lat: [\n      data[lat].data.reduce((a, b) => Math.min(a, b)),\n      data[lat].data.reduce((a, b) => Math.max(a, b)),\n    ],\n    lon: [\n      data[lon].data.reduce((a, b) => Math.min(a, b)),\n      data[lon].data.reduce((a, b) => Math.max(a, b)),\n    ],\n  }\n}\n\nconst NORTH_POLE = [0, 90]\n\nconst Raster = ({\n  source,\n  variable,\n  mode = 'rgb',\n  colormap = null,\n  clim = null,\n  transpose,\n  northPole = NORTH_POLE,\n  nullValue = -999,\n  bounds = null,\n  lat = 'lat',\n  lon = 'lon',\n}) => {\n  const { viewport, regl } = useRegl()\n  const { scale, translate, projection } = useMinimap()\n\n  if (mode == 'lut' && !colormap) {\n    throw new Error(\"must provide 'colormap' when using 'lut' mode\")\n  }\n\n  if (mode == 'lut' && !clim) {\n    throw new Error(\"must provide 'clim' when using 'lut' mode\")\n  }\n\n  const redraw = useRef()\n  const draw = useRef()\n  const texture = useRef()\n  const lut = useRef()\n  const context = useRef({})\n  const isLoaded = useRef(false)\n  const boundsRef = useRef(null)\n  const zarrGroupCache = useRef()\n  const invalidated = useRef(null)\n\n  useEffect(() => {\n    regl.frame((_context) => {\n      context.current = _context\n\n      if (invalidated.current) {\n        regl.clear({\n          color: [0, 0, 0, 0],\n          depth: 1,\n        })\n\n        redraw.current(invalidated.current)\n      }\n      invalidated.current = null\n    })\n  }, [])\n\n  useEffect(() => {\n    texture.current ||= regl.texture({\n      width: 1,\n      height: 1,\n      data: [0, 0, 0, 0],\n    })\n\n    lut.current ||= regl.texture()\n\n    const position = [\n      0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0,\n    ]\n\n    let uniforms = {\n      pixelRatio: regl.prop('pixelRatio'),\n      viewportWidth: regl.prop('viewportWidth'),\n      viewportHeight: regl.prop('viewportHeight'),\n      texture: regl.prop('texture'),\n      scale: regl.prop('scale'),\n      translate: regl.prop('translate'),\n      northPole: regl.prop('northPole'),\n      transpose: regl.prop('transpose'),\n      nullValue: regl.prop('nullValue'),\n      bounds: regl.prop('bounds'),\n    }\n\n    if (mode === 'lut') {\n      uniforms = {\n        ...uniforms,\n        lut: regl.prop('lut'),\n        clim: regl.prop('clim'),\n      }\n    }\n\n    draw.current = regl({\n      vert: `\n      #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      #else\n      precision mediump float;\n      #endif\n      attribute vec2 position;\n      varying vec2 uv;\n      void main() {\n        uv = vec2(position.y, position.x);\n        gl_Position = vec4(2.0 * position.x - 1.0, 2.0 * position.y - 1.0, 0.0, 1.0);\n      }\n      `,\n\n      frag: `\n      #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      #else\n      precision mediump float;\n      #endif\n      varying vec2 uv;\n      uniform vec2 clim;\n      uniform vec4 bounds;\n      uniform float viewportWidth;\n      uniform float viewportHeight;\n      uniform sampler2D texture;\n      uniform float pixelRatio;\n      uniform float scale;\n      uniform vec2 translate;\n      uniform vec2 northPole;\n      uniform bool transpose;\n      uniform float nullValue;\n      ${mode === 'lut' ? 'uniform sampler2D lut;' : ''}\n      ${mode === 'lut' ? 'uniform vec3 nullColor;' : ''}\n\n      const float pi = 3.14159265358979323846264;\n      const float halfPi = pi * 0.5;\n      const float twoPi = pi * 2.0;\n\n      bool isnan(float val)\n      {\n        return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;\n      }\n\n      vec2 rotateCoords(vec2 coords, vec2 northPole) {\n        // Calculate rotation based of north pole coordinates of rotated grid\n        float phiOffset = northPole.y == 90.0 ? 0.0 : 180.0;\n        float phi = radians(phiOffset + northPole.x);\n        float theta = radians(-1.0 * (90.0 - northPole.y));\n\n        float lon = radians(coords.x);\n        float lat = radians(coords.y);\n\n        // Convert from spherical to cartesian coordinates\n        vec3 unrotatedCoord = vec3(cos(lon) * cos(lat), sin(lon) * cos(lat), sin(lat));\n\n        // From https://en.wikipedia.org/wiki/Rotation_matrix#General_rotations\n        mat3 intrinsicRotation = mat3(\n          cos(phi) * cos(theta), -1.0 * sin(phi), cos(phi) * sin(theta),\n          sin(phi) * cos(theta), cos(phi)       , sin(phi) * sin(theta),\n          -1.0 * sin(theta)    , 0              , cos(theta)\n        );\n\n        vec3 rotatedCoord = intrinsicRotation * unrotatedCoord;\n\n        // Convert from cartesian to spherical coordinates\n        float rotatedLon = degrees(atan(rotatedCoord.y, rotatedCoord.x));\n        float rotatedLat = degrees(asin(rotatedCoord.z));\n\n        return vec2(rotatedLon, rotatedLat);\n      }\n\n      ${projection.glsl.func}\n      void main() {\n        \n        float width = viewportWidth / pixelRatio;\n        float height = viewportHeight / pixelRatio;\n        float x = gl_FragCoord.x / pixelRatio;\n        float y = gl_FragCoord.y / pixelRatio;\n\n        vec2 delta = vec2((1.0 + translate.x) * width / 2.0, (1.0 - translate.y) * height / 2.0);        \n\n        x = (x - delta.x) / (scale * (width / (pi * 2.0)));\n        ${\n          transpose\n            ? `y = (delta.y - y) / (scale * (width / (pi * 2.0)));`\n            : `y = (y - delta.y) / (scale * (width / (pi * 2.0)));`\n        }\n\n        vec2 lookup = ${projection.glsl.name}(x, y);\n        vec2 rotated = rotateCoords(lookup, northPole);\n\n        // Handle points that wrap\n        float offsetX = 0.0;\n        if (rotated.x < bounds[2]) {\n          offsetX = 360.0;\n        } else if (rotated.x > bounds[3]) {\n          offsetX = -360.0;\n        }\n\n        float scaleY = 180.0 / abs(bounds[0] - bounds[1]);\n        float scaleX = 360.0 / abs(bounds[2] - bounds[3]);\n        float translateY = 90.0 + bounds[0];\n        float translateX = 180.0 + bounds[2];\n\n        float rescaledY = scaleY * (radians(rotated.y - translateY) + halfPi) / pi;\n        float rescaledX = scaleX * (radians(rotated.x + offsetX - translateX) + pi) / twoPi;\n\n        vec2 coord;\n        ${\n          transpose\n            ? `coord = vec2(rescaledX, rescaledY);`\n            : `coord = vec2(rescaledY, rescaledX);`\n        }\n\n        vec4 value = texture2D(texture, coord);\n\n        bool inboundsY = rotated.y > bounds[0] && rotated.y < bounds[1];\n        bool inboundsX = rotated.x + offsetX > bounds[2] && rotated.x + offsetX < bounds[3];\n\n        ${\n          mode === 'lut'\n            ? `\n          vec4 c;\n          if ((!inboundsY || !inboundsX) || (value.x == nullValue || isnan(value.x))) {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n          } else {\n            float rescaled = (value.x - clim.x)/(clim.y - clim.x);\n            c = texture2D(lut, vec2(rescaled, 1.0));\n            gl_FragColor = vec4(c.x, c.y, c.z, 1.0);\n          }`\n            : ''\n        }\n\n        ${\n          mode === 'rgb'\n            ? `\n          if (value.x == nullValue) {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n          } else {\n            gl_FragColor = vec4(value.x , value.y, value.z, 1.0);\n          }\n        `\n            : ''\n        }\n      }\n      `,\n\n      attributes: {\n        position: position,\n      },\n\n      uniforms: uniforms,\n\n      count: 6,\n\n      primitive: 'triangles',\n    })\n  }, [projection.glsl.name])\n\n  redraw.current = (invalidatedBy) => {\n    if (draw.current && isLoaded.current) {\n      const { pixelRatio } = context.current\n      draw.current({\n        texture: texture.current,\n        lut: lut.current,\n        bounds: boundsRef.current\n          ? [\n              boundsRef.current.lat[0],\n              boundsRef.current.lat[1],\n              boundsRef.current.lon[0],\n              boundsRef.current.lon[1],\n            ]\n          : [-90, 90, -180, 180],\n        scale,\n        translate,\n        northPole,\n        clim,\n        nullValue,\n        viewportWidth: viewport.width * pixelRatio,\n        viewportHeight: viewport.height * pixelRatio,\n        pixelRatio,\n      })\n    }\n  }\n\n  useEffect(() => {\n    // handle loading asynchronously from a specified path\n    if (typeof source === 'string') {\n      const ext = extname(source)\n\n      // handle images\n      if (['.png', '.jpg', '.jpeg'].includes(ext)) {\n        const image = document.createElement('img')\n        image.src = source\n        image.crossOrigin = 'anonymous'\n        image.onload = function () {\n          setTimeout(() => {\n            isLoaded.current = true\n            texture.current(image)\n            invalidated.current = 'on image load'\n          }, 0)\n        }\n      }\n\n      // handle zarr groups and arrays\n      if (ext === '.zarr') {\n        if (variable) {\n          zarr().loadGroup(source, (error, data, metadata) => {\n            validateGroup(data, variable)\n\n            if (!bounds && data[lat] && data[lon]) {\n              boundsRef.current = getBounds({ data, lat, lon })\n            }\n            zarrGroupCache.current = data\n            isLoaded.current = true\n            texture.current(zarrGroupCache.current[variable])\n            invalidated.current = 'on zarr group load'\n          })\n        } else {\n          zarr().load(source, (error, data) => {\n            isLoaded.current = true\n            texture.current(data)\n            invalidated.current = 'on zarr array load'\n          })\n        }\n      }\n      // handle loading synchronously from pre-fetched zarr data\n    } else {\n      if (variable) {\n        validateGroup(source, variable)\n\n        if (!bounds && source[lat] && source[lon]) {\n          boundsRef.current = getBounds({ data: source, lat, lon })\n        }\n\n        zarrGroupCache.current = source\n        isLoaded.current = true\n        texture.current(zarrGroupCache.current[variable])\n        invalidated.current = 'on zarr group read'\n      } else {\n        isLoaded.current = true\n        texture.current(source)\n        invalidated.current = 'on zarr array read'\n      }\n    }\n  }, [source, lat, lon])\n\n  useEffect(() => {\n    // handle variable change on cached zarr group data\n    if (zarrGroupCache.current) {\n      texture.current(zarrGroupCache.current[variable])\n      invalidated.current = 'on variable change'\n    }\n  }, [variable])\n\n  useEffect(() => {\n    if (bounds) {\n      boundsRef.current = bounds\n    }\n    invalidated.current = 'on bounds change'\n  }, [\n    bounds && bounds.lat[0],\n    bounds && bounds.lat[1],\n    bounds && bounds.lon[0],\n    bounds && bounds.lon[1],\n  ])\n\n  useEffect(() => {\n    if (colormap) {\n      lut.current({\n        data: colormap,\n        format: 'rgb',\n        shape: [colormap.length, 1],\n      })\n      invalidated.current = 'on colormap change'\n    }\n  }, [colormap])\n\n  useEffect(() => {\n    invalidated.current = 'on viewport change'\n  }, [viewport])\n\n  useEffect(() => {\n    invalidated.current = 'on prop change'\n  }, [\n    clim && clim[0],\n    clim && clim[1],\n    mode,\n    scale,\n    translate[0],\n    translate[1],\n    northPole ? northPole[0] : undefined,\n    northPole ? northPole[1] : undefined,\n    nullValue,\n    projection,\n  ])\n\n  return null\n}\n\nexport default Raster\n","import React, { useState, useEffect } from 'react'\nimport { geoPath } from 'd3-geo'\nimport { useMinimap } from './minimap'\n\nconst Sphere = ({ fill, stroke, strokeWidth = 0.5, opacity = 0.2 }) => {\n  const { projection, width, height } = useMinimap()\n  const [path, setPath] = useState()\n  // replace with uui\n  const id = String(Math.floor(Math.random() * 100))\n\n  useEffect(() => {\n    setPath(geoPath(projection)({ type: 'Sphere' }))\n  }, [projection])\n\n  return (\n    <svg\n      viewBox={`0 0 ${width} ${height}`}\n      style={{ position: 'absolute', width: '100%', top: 0, left: 0 }}\n    >\n      <mask id={id}>\n        <rect x='0' y='0' width='100%' height='100%' fill='#FFFFFF' />\n        <path fill='#000000' id='circle-cutout' d={path} />\n      </mask>\n      <rect\n        x='0'\n        y='0'\n        width='100%'\n        height='100%'\n        mask={`url(#${id})`}\n        style={{ fill: fill }}\n      />\n      {stroke && (\n        <path\n          fill='none'\n          stroke={stroke}\n          strokeWidth={strokeWidth}\n          opacity={opacity}\n          style={{\n            vectorEffect: 'non-scaling-stroke',\n          }}\n          d={path}\n        />\n      )}\n    </svg>\n  )\n}\n\nexport default Sphere\n","import React, { useEffect, useState } from 'react'\nimport { geoPath } from 'd3-geo'\nimport { feature as topoFeature } from 'topojson-client'\nimport { useMinimap } from './minimap'\n\nconst Path = ({\n  source,\n  feature,\n  fill = 'none',\n  stroke = 'none',\n  strokeWidth = 0.5,\n  opacity = 0.7,\n}) => {\n  const [path, setPath] = useState()\n  const [data, setData] = useState()\n  const { projection, width, height } = useMinimap()\n\n  useEffect(() => {\n    fetch(source)\n      .then((response) => response.json())\n      .then((topology) => {\n        setData(topoFeature(topology, topology.objects[feature]))\n      })\n  }, [source])\n\n  useEffect(() => {\n    setPath(geoPath(projection)(data))\n  }, [data, projection])\n\n  return (\n    <path\n      d={path}\n      stroke={stroke}\n      fill={fill}\n      opacity={opacity}\n      strokeWidth={strokeWidth}\n      style={{\n        vectorEffect: 'non-scaling-stroke',\n      }}\n    />\n  )\n}\n\nexport default Path\n","import React from 'react'\nimport { geoPath, geoGraticule } from 'd3-geo'\nimport { useMinimap } from './minimap'\n\nconst Graticule = ({\n  stroke,\n  strokeWidth = 0.5,\n  step = [45, 45],\n  opacity = 0.2,\n}) => {\n  const { projection, width, height } = useMinimap()\n\n  const eps = projection.id === 'mercator' ? 0 : 0.1\n\n  return (\n    <path\n      d={geoPath(projection)(\n        geoGraticule()\n          .step(step)\n          .extentMajor([\n            [-180 - eps, -90 - eps],\n            [180 + eps, 90 + eps],\n          ])()\n      )}\n      stroke={stroke}\n      fill={'none'}\n      opacity={opacity}\n      strokeWidth={strokeWidth}\n      style={{\n        vectorEffect: 'non-scaling-stroke',\n      }}\n    />\n  )\n}\n\nexport default Graticule\n"],"names":["ReglContext","createContext","Regl","style","aspect","children","regl","useRef","container","resize","ready","setReady","useState","viewport","setViewport","width","height","useEffect","current","offsetWidth","window","addEventListener","_regl","extensions","removeEventListener","destroy","React","createElement","Provider","value","_extends","ref","DEFAULTS","naturalEarth1","scale","translate","orthographic","mercator","equirectangular","MinimapContext","useMinimap","useContext","Minimap","id","tabIndex","className","projection","getProjection","aspectProp","scaleProp","translateProp","setProjection","WIDTH","updatedProjection","defaults","updatedScale","updatedAspect","updatedTranslate","Math","PI","position","overflow","pointerEvents","zIndex","viewBox","top","left","validateGroup","data","variable","Object","keys","includes","Error","getBounds","lat","lon","reduce","a","b","min","max","NORTH_POLE","Raster","source","mode","colormap","clim","transpose","northPole","nullValue","bounds","redraw","draw","texture","lut","context","isLoaded","boundsRef","zarrGroupCache","invalidated","frame","_context","clear","color","depth","uniforms","pixelRatio","prop","viewportWidth","viewportHeight","vert","frag","glsl","func","name","attributes","count","primitive","invalidatedBy","ext","extname","image","document","src","crossOrigin","onload","setTimeout","zarr","loadGroup","error","metadata","load","format","shape","length","undefined","Sphere","fill","stroke","strokeWidth","opacity","path","setPath","String","floor","random","geoPath","type","x","y","d","mask","vectorEffect","Path","feature","setData","fetch","then","response","json","topology","topoFeature","objects","Graticule","step","eps","geoGraticule","extentMajor"],"mappings":"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"}